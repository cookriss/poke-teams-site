<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detalles del Equipo Pokémon</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary: #ff5350; --primary-dark: #d13330; --secondary: #3b4cca; --light: #f8f9fa;
            --dark: #343a40; --success: #30c58b; --danger: #dc3545;
            --type-normal: #A8A77A; --type-fire: #EE8130; --type-water: #6390F0; --type-electric: #F7D02C;
            --type-grass: #7AC74C; --type-ice: #96D9D6; --type-fighting: #C22E28; --type-poison: #A33EA1;
            --type-ground: #E2BF65; --type-flying: #A98FF3; --type-psychic: #F95587; --type-bug: #A6B91A;
            --type-rock: #B6A136; --type-ghost: #735797; --type-dragon: #6F35FC; --type-dark: #705746;
            --type-steel: #B7B7CE; --type-fairy: #D685AD;
        }
        body { background-color: #f4f4f4; color: var(--dark); line-height: 1.6; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; }
        .container { width: 90%; max-width: 900px; margin: 20px auto; background-color: white; padding: 25px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        .detail-page-title { color: var(--primary); margin-bottom: 1.5rem; border-bottom: 2px solid var(--primary); padding-bottom: 0.75rem; text-align: center;}
        .detail-section { margin-bottom: 2rem; }
        .detail-section h3 { color: var(--secondary); margin-bottom: 0.75rem; border-bottom: 1px solid #eee; padding-bottom: 0.5rem;}
        
        .pokemon-details-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem; }
        .pokemon-detail-card { border: 1px solid #e0e0e0; border-radius: 8px; padding: 1rem; background-color: #f9f9f9; display: flex; flex-direction: column; }
        .pokemon-detail-header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; }
        .pokemon-detail-sprite { width: 80px; height: 80px; object-fit: contain; background-color: #e9e9e9; border-radius: 50%; image-rendering: pixelated; border: 1px solid #ccc;}
        .pokemon-detail-item-sprite { width: 36px; height: 36px; object-fit: contain; margin-left: auto; background-color: #e9e9e9; border-radius: 5px; padding: 3px; border: 1px solid #ccc;}
        .pokemon-detail-name { font-size: 1.3rem; font-weight: bold; color: var(--secondary); flex-grow: 1; }
        .pokemon-detail-info { font-size: 0.9rem; margin-bottom: 0.4rem; }
        .pokemon-detail-info strong { color: var(--dark); }
        .pokemon-moves-title { font-weight: bold; margin-top: 1rem; margin-bottom: 0.5rem; font-size: 1rem;}
        .pokemon-moves-list { list-style: none; padding-left: 0; }
        .pokemon-moves-list li { display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0.75rem; border-radius: 5px; margin-bottom: 0.4rem; font-size: 0.9rem; color: white; }
        .move-name { flex-grow: 1; }
        .move-category-icon { width: 20px; height: 20px; margin-left: 0.75rem; vertical-align: middle; }
        
        .youtube-embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px;}
        .youtube-embed-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .type-tag { padding: 0.2em 0.6em; border-radius: 4px; color: white; font-size: 0.85em; text-transform: uppercase; margin-left: 5px;}

        .type-analysis-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem; margin-bottom: 1.5rem; }
        .type-analysis-section h4 { color: var(--primary-dark); margin-bottom: 0.5rem; }
        .type-analysis-list { list-style: none; padding-left: 0; font-size: 0.9rem; }
        .type-analysis-list li { padding: 0.3rem 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #f0f0f0; }
        .type-analysis-list li:last-child { border-bottom: none; }
        .type-analysis-list .type-name-container { display: flex; align-items: center; gap: 0.5rem;}
        .type-analysis-list .count { font-weight: bold; padding: 0.1rem 0.5rem; border-radius: 10px; background-color: #e0e0e0; font-size: 0.85em; color: var(--dark); }
        .type-analysis-list .weak .count { background-color: var(--danger); color: white; }
        .type-analysis-list .resist .count { background-color: var(--success); color: white; }

        .ev-chart-container { max-width: 250px; margin: 1rem auto 0; } 

        .comments-section { margin-top: 2rem; }
        .comments-toolbar { display: flex; justify-content: flex-end; align-items: center; margin-bottom: 1rem; gap: 1rem;}
        .comments-toolbar label { font-size: 0.9rem; }
        .comments-toolbar select { padding: 0.3rem 0.5rem; border-radius: 4px; border: 1px solid #ccc; font-size: 0.9rem;}
        .comment-form textarea { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 5px; min-height: 80px; margin-bottom: 0.5rem; font-size: 0.95rem; }
        .comment-form button { background-color: var(--primary); color: white; padding: 0.6rem 1.2rem; border: none; border-radius: 20px; cursor: pointer; font-weight: bold; }
        .comment-form button:hover { background-color: var(--primary-dark); }
        .comments-list { margin-top: 1.5rem; list-style: none; padding-left: 0; }
        .comment-item { background-color: #f9f9f9; border: 1px solid #eee; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; }
        .comment-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .comment-author { font-weight: bold; color: var(--secondary); }
        .comment-date { font-size: 0.8rem; color: #777; }
        .comment-text { font-size: 0.95rem; white-space: pre-wrap; margin-bottom: 0.75rem; }
        .comment-actions { display: flex; align-items: center; gap: 0.75rem; }
        .comment-actions .vote-button { background: none; border: none; cursor: pointer; font-size: 1.1rem; padding: 0.2rem; line-height: 1; }
        .comment-actions .vote-button:hover { color: var(--primary); }
        .comment-actions .vote-count { font-size: 0.9rem; font-weight: bold; }
        .comment-actions .reply-button { font-size: 0.8rem; color: var(--secondary); background: none; border: none; cursor: pointer; padding: 0.2rem; }
        .comment-actions .reply-button:hover { text-decoration: underline; }


        #loading-indicator { text-align: center; font-size: 1.2rem; color: var(--secondary); padding: 2rem; }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="detail-team-title" class="detail-page-title">Cargando detalles del equipo...</h1>
        <div id="loading-indicator">Cargando...</div>

        <div id="team-detail-content" style="display: none;">
            <section class="detail-section">
                <h3>Pokémon del Equipo</h3>
                <div id="detail-pokemon-container" class="pokemon-details-grid"></div>
            </section>

            <section class="detail-section">
                <h3>Análisis de Tipos del Equipo</h3>
                <div class="type-analysis-grid">
                    <div class="type-analysis-section" id="team-weaknesses">
                        <h4>Debilidades Defensivas</h4>
                        <ul class="type-analysis-list" id="weakness-list"></ul>
                    </div>
                    <div class="type-analysis-section" id="team-offense">
                        <h4>Cobertura Ofensiva</h4>
                        <ul class="type-analysis-list" id="offense-list"></ul>
                    </div>
                </div>
            </section>

            <section class="detail-section">
                <h3>Descripción del Creador</h3>
                <p id="detail-team-creator-description">No hay descripción disponible.</p>
            </section>

            <section class="detail-section">
                <h3>Vídeo Guía</h3>
                <div id="detail-youtube-embed" class="youtube-embed-container">
                    <p>No hay vídeo guía disponible.</p>
                </div>
            </section>

            <section class="detail-section comments-section">
                <h3>Comentarios</h3>
                <div class="comments-toolbar">
                    <label for="sort-comments">Ordenar por:</label>
                    <select id="sort-comments">
                        <option value="newest">Más nuevos primero</option>
                        <option value="mostVoted">Más votados primero</option>
                    </select>
                </div>
                <form id="comment-form" class="comment-form">
                    <div class="form-group">
                        <label for="comment-text">Escribe un comentario:</label>
                        <textarea id="comment-text" name="commentText" required></textarea>
                    </div>
                    <button type="submit">Enviar Comentario</button>
                </form>
                <div id="comment-feedback" class="feedback-message" style="display:none;"></div>
                <ul id="comments-list" class="comments-list"></ul>
            </section>
        </div>
    </div>

    <script>
        const TYPE_EFFECTIVENESS = {
            normal: { rock: 0.5, steel: 0.5, ghost: 0 }, fire: { fire: 0.5, water: 0.5, grass: 2, ice: 2, bug: 2, rock: 0.5, dragon: 0.5, steel: 2 },
            water: { fire: 2, water: 0.5, grass: 0.5, ground: 2, rock: 2, dragon: 0.5 }, electric: { water: 2, grass: 0.5, electric: 0.5, ground: 0, flying: 2, dragon: 0.5 },
            grass: { fire: 0.5, water: 2, grass: 0.5, poison: 0.5, ground: 2, flying: 0.5, bug: 0.5, rock: 2, dragon: 0.5, steel: 0.5 }, ice: { fire: 0.5, water: 0.5, grass: 2, ice: 0.5, ground: 2, flying: 2, dragon: 2, steel: 0.5 },
            fighting: { normal: 2, ice: 2, poison: 0.5, flying: 0.5, psychic: 0.5, bug: 0.5, rock: 2, ghost: 0, dark: 2, steel: 2, fairy: 0.5 }, poison: { grass: 2, poison: 0.5, ground: 0.5, rock: 0.5, ghost: 0.5, steel: 0, fairy: 2 },
            ground: { fire: 2, grass: 0.5, electric: 2, poison: 2, flying: 0, bug: 0.5, rock: 2, steel: 2 }, flying: { grass: 2, electric: 0.5, fighting: 2, bug: 2, rock: 0.5, steel: 0.5 },
            psychic: { fighting: 2, poison: 2, psychic: 0.5, dark: 0, steel: 0.5 }, bug: { fire: 0.5, grass: 2, fighting: 0.5, poison: 0.5, flying: 0.5, psychic: 2, ghost: 0.5, dark: 2, steel: 0.5, fairy: 0.5 },
            rock: { fire: 2, ice: 2, fighting: 0.5, ground: 0.5, flying: 2, bug: 2, steel: 0.5 }, ghost: { normal: 0, psychic: 2, ghost: 2, dark: 0.5 },
            dragon: { dragon: 2, steel: 0.5, fairy: 0 }, dark: { fighting: 0.5, psychic: 2, ghost: 2, dark: 0.5, fairy: 0.5 },
            steel: { fire: 0.5, water: 0.5, electric: 0.5, ice: 2, rock: 2, steel: 0.5, fairy: 2 }, fairy: { fire: 0.5, fighting: 2, poison: 0.5, dragon: 2, dark: 2, steel: 0.5 }
        };
        const ALL_TYPES = ["normal", "fire", "water", "electric", "grass", "ice", "fighting", "poison", "ground", "flying", "psychic", "bug", "rock", "ghost", "dragon", "dark", "steel", "fairy"];
        let currentTeamDataForDetail = null; 
        let evCharts = {}; 

        document.addEventListener('DOMContentLoaded', async () => {
            const params = new URLSearchParams(window.location.search);
            const teamId = params.get('teamId');

            const pageTitleElement = document.getElementById('detail-team-title');
            const loadingIndicator = document.getElementById('loading-indicator');
            const teamDetailContent = document.getElementById('team-detail-content');
            
            const pokemonContainer = document.getElementById('detail-pokemon-container');
            const descriptionElement = document.getElementById('detail-team-creator-description');
            const youtubeEmbedContainer = document.getElementById('detail-youtube-embed');
            const weaknessListElement = document.getElementById('weakness-list');
            const offenseListElement = document.getElementById('offense-list');
            const commentForm = document.getElementById('comment-form');
            const commentsListElement = document.getElementById('comments-list');
            const commentFeedback = document.getElementById('comment-feedback');
            const sortCommentsDropdown = document.getElementById('sort-comments');

            if (!teamId) {
                pageTitleElement.textContent = "Error: ID de equipo no proporcionado.";
                if(loadingIndicator) loadingIndicator.style.display = 'none';
                return;
            }

            currentTeamDataForDetail = JSON.parse(localStorage.getItem('currentTeamDetails'));
            if (!currentTeamDataForDetail || currentTeamDataForDetail.id !== teamId) {
                const allTeams = JSON.parse(localStorage.getItem('allTeamsData')) || {};
                if (allTeams[teamId]) {
                    currentTeamDataForDetail = allTeams[teamId];
                    localStorage.setItem('currentTeamDetails', JSON.stringify(currentTeamDataForDetail));
                } else {
                    pageTitleElement.textContent = `Error: No se pudieron cargar los detalles para el equipo ${teamId}.`;
                    if(loadingIndicator) loadingIndicator.style.display = 'none';
                    return;
                }
            }
            
            pageTitleElement.textContent = currentTeamDataForDetail.title || "Detalles del Equipo";
            descriptionElement.textContent = currentTeamDataForDetail.description || "No hay descripción disponible.";

            youtubeEmbedContainer.innerHTML = '';
            if (currentTeamDataForDetail.youtubeLink) {
                const videoId = extractYouTubeVideoID(currentTeamDataForDetail.youtubeLink);
                if (videoId) {
                    const iframe = document.createElement('iframe');
                    iframe.src = `https://www.youtube.com/embed/${videoId}`;
                    iframe.frameBorder = "0"; iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"; iframe.allowFullscreen = true;
                    youtubeEmbedContainer.appendChild(iframe);
                } else { youtubeEmbedContainer.innerHTML = '<p>Enlace de YouTube no válido.</p>'; }
            } else { youtubeEmbedContainer.innerHTML = '<p>No hay vídeo guía disponible.</p>'; }

            await displayFullPokemonDetails(currentTeamDataForDetail.pokemons, pokemonContainer);
            
            const detailedPokemonsForAnalysis = await Promise.all(currentTeamDataForDetail.pokemons.map(async (p) => {
                const pokeApiName = p.name.toLowerCase().replace(/\s+/g, '-');
                const apiData = await fetchFromPokeAPI(`pokemon/${pokeApiName}`);
                const movesData = await Promise.all((p.moves || []).map(m => fetchFromPokeAPI(`move/${m.toLowerCase().replace(/\s+/g, '-')}`)));
                return { ...p, apiTypes: apiData ? apiData.types.map(t => t.type.name) : p.types || [], apiMoves: movesData.filter(m => m).map(m => ({ name: m.name, type: m.type.name, damage_class: m.damage_class.name })) };
            }));

            analyzeAndDisplayTeamWeaknesses(detailedPokemonsForAnalysis, weaknessListElement);
            analyzeAndDisplayOffensiveCoverage(detailedPokemonsForAnalysis, offenseListElement);

            renderComments(currentTeamDataForDetail.comments || [], commentsListElement, sortCommentsDropdown.value);

            if (commentForm) {
                commentForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const commentTextElement = document.getElementById('comment-text');
                    const commentText = commentTextElement.value.trim();
                    const storedUser = JSON.parse(localStorage.getItem('userData')); // Asumiendo que guardas datos del usuario logueado
                    const author = storedUser ? storedUser.username : "Anónimo";

                    if (commentText) {
                        const newComment = { author: author, date: new Date().toISOString(), text: commentText, id: `comment-${Date.now()}`, votes: 0 };
                        if (!currentTeamDataForDetail.comments) currentTeamDataForDetail.comments = [];
                        currentTeamDataForDetail.comments.push(newComment);
                        
                        localStorage.setItem('currentTeamDetails', JSON.stringify(currentTeamDataForDetail)); 
                        let allTeams = JSON.parse(localStorage.getItem('allTeamsData')) || {};
                        if(allTeams[teamId]) {
                            allTeams[teamId] = currentTeamDataForDetail; 
                            localStorage.setItem('allTeamsData', JSON.stringify(allTeams));
                        }

                        renderComments(currentTeamDataForDetail.comments, commentsListElement, sortCommentsDropdown.value);
                        commentTextElement.value = '';
                        if(commentFeedback) showFeedback(commentFeedback, "Comentario añadido.", false);
                    } else { if(commentFeedback) showFeedback(commentFeedback, "El comentario no puede estar vacío.", true); }
                });
            }
            
            if (sortCommentsDropdown) {
                sortCommentsDropdown.addEventListener('change', () => {
                    renderComments(currentTeamDataForDetail.comments || [], commentsListElement, sortCommentsDropdown.value);
                });
            }

            if(loadingIndicator) loadingIndicator.style.display = 'none';
            if(teamDetailContent) teamDetailContent.style.display = 'block';
        });

        async function fetchFromPokeAPI(endpoint) {
             try {
                const response = await fetch(`https://pokeapi.co/api/v2/${endpoint}`);
                if (!response.ok) { console.warn(`Recurso no encontrado en PokéAPI: ${endpoint} (Status: ${response.status})`); return null; }
                return await response.json();
            } catch (error) { console.error(`Error fetching de PokéAPI (${endpoint}):`, error); return null; }
        }
        function getTypeColor(typeName) { return `var(--type-${typeName.toLowerCase()}, var(--dark))`; }
        function getMoveCategoryIcon(category) {
            // Usando SVGs inline más simples y pequeños
            if (category === 'physical') return `<svg width="20" height="20" viewBox="0 0 100 100" class="move-category-icon" fill="#CD281A" title="Físico"><path d="M89.39,38.38,63.5,12.49a5,5,0,0,0-7.08,0L44.6,24.31,24.31,44.6a5,5,0,0,0,0,7.08L38.88,66.25,10.61,94.53a2.5,2.5,0,0,0,0,3.53,2.43,2.43,0,0,0,1.76.74,2.39,2.39,0,0,0,1.77-.74L42.38,69.28,57,83.87a5,5,0,0,0,7.08,0L75.9,72.05,96.19,51.77a5,5,0,0,0,0-7.07ZM59.11,79.39,46.38,66.67l9.25-9.25,12.73,12.72Zm6.36-6.36L52.74,59.87l9.26-9.25L74.72,63.34ZM71.66,52,58.93,39.28,71.66,26.56,84.39,39.28Z"/></svg>`;
            if (category === 'special') return `<svg width="20" height="20" viewBox="0 0 100 100" class="move-category-icon" fill="#4A54D1" title="Especial"><path d="M50,10A40,40,0,1,0,90,50,40,40,0,0,0,50,10Zm0,72A32,32,0,1,1,82,50,32,32,0,0,1,50,82Z"/><circle cx="50" cy="50" r="18" fill="#4A54D1"/></svg>`;
            if (category === 'status') return `<svg width="20" height="20" viewBox="0 0 100 100" class="move-category-icon" fill="#8A8A8A" title="Estado"><path d="M50,10A40,40,0,1,0,90,50,40,40,0,0,0,50,10Zm0,72A32,32,0,1,1,82,50,32,32,0,0,1,50,82Z"/><path d="M50,30A20,20,0,1,0,70,50,20,20,0,0,0,50,30Zm0,32A12,12,0,1,1,62,50,12,12,0,0,1,50,62Z"/></svg>`;
            return '';
        }
        
        async function displayFullPokemonDetails(pokemonList, container) {
            if (!container) return;
            container.innerHTML = ''; 
            const pokemonPromises = pokemonList.map(async (p, index) => {
                const pokeApiName = p.name.toLowerCase().replace(/\s+/g, '-');
                const pokeApiData = await fetchFromPokeAPI(`pokemon/${pokeApiName}`);
                const itemApiData = p.item ? await fetchFromPokeAPI(`item/${p.item.toLowerCase().replace(/\s+/g, '-')}`) : null;
                
                let movesHtml = '<ul class="pokemon-moves-list">';
                const movePromises = (p.moves || []).map(async (moveName) => {
                    const moveApiName = moveName.toLowerCase().replace(/\s+/g, '-');
                    const moveData = await fetchFromPokeAPI(`move/${moveApiName}`);
                    if (moveData) {
                        const typeName = moveData.type.name; const category = moveData.damage_class.name;
                        const moveDisplayName = moveData.names.find(n => n.language.name === 'es')?.name || moveName.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        return `<li style="background-color: ${getTypeColor(typeName)};"><span class="move-name">${moveDisplayName}</span>${getMoveCategoryIcon(category)}</li>`;
                    }
                    return `<li>${moveName.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} (datos no disp.)</li>`;
                });
                const resolvedMoves = await Promise.all(movePromises);
                movesHtml += resolvedMoves.join('') + '</ul>';

                const evChartId = `ev-chart-${pokeApiName}-${index}`;
                const evChartHtml = `<div class="ev-chart-container"><canvas id="${evChartId}"></canvas></div>`;

                return `
                    <div class="pokemon-detail-card">
                        <div class="pokemon-detail-header">
                            <img src="${pokeApiData?.sprites?.front_default || 'https://play.pokemonshowdown.com/sprites/ani/'+pokeApiName+'.gif'}" 
                                 alt="${p.name}" class="pokemon-detail-sprite" 
                                 onerror="this.onerror=null; this.src='https://placehold.co/80x80/cccccc/969696?text=${p.name.substring(0,1).toUpperCase()}&font=roboto';">
                            <div>
                                <h4 class="pokemon-detail-name">${p.name.charAt(0).toUpperCase() + p.name.slice(1)}</h4>
                                ${p.teraType ? `<div class="pokemon-detail-info"><strong>Teratipo:</strong> <span class="type-tag" style="background-color:${getTypeColor(p.teraType)};">${p.teraType.toUpperCase()}</span></div>` : ''}
                            </div>
                            ${itemApiData?.sprites?.default ? `<img src="${itemApiData.sprites.default}" alt="${p.item}" class="pokemon-detail-item-sprite" title="${p.item}">` : `<span class="pokemon-detail-item-sprite" title="${p.item || 'Ninguno'}">${p.item ? '📦' : ''}</span>`}
                        </div>
                        <div class="pokemon-detail-info"><strong>Objeto:</strong> ${p.item ? p.item.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Ninguno'}</div>
                        <div class="pokemon-detail-info"><strong>Habilidad:</strong> ${p.ability ? p.ability.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'N/A'}</div>
                        <div class="pokemon-detail-info"><strong>EVs:</strong> ${p.evs || 'N/A'}</div>
                        ${evChartHtml}
                        <div class="pokemon-detail-info"><strong>Naturaleza:</strong> ${p.nature || 'N/A'}</div>
                        <h5 class="pokemon-moves-title">Movimientos:</h5>
                        ${movesHtml}
                    </div>`;
            });
            const resolvedPokemonHtml = await Promise.all(pokemonPromises);
            container.innerHTML = resolvedPokemonHtml.join('');

            pokemonList.forEach((p, index) => {
                const pokeApiName = p.name.toLowerCase().replace(/\s+/g, '-');
                const evChartId = `ev-chart-${pokeApiName}-${index}`;
                renderEVChart(p.evs, evChartId);
            });
        }

        function parseEVs(evString) {
            const evs = { HP: 0, Atk: 0, Def: 0, SpA: 0, SpD: 0, Spe: 0 };
            if (!evString) return Object.values(evs);
            const parts = evString.split('/');
            parts.forEach(part => {
                const match = part.trim().match(/(\d+)\s+(HP|Atk|Def|SpA|SpD|Spe)/i);
                if (match && evs.hasOwnProperty(match[2].toUpperCase())) { 
                    evs[match[2].toUpperCase()] = parseInt(match[1]);
                }
            });
            return [evs.HP, evs.Atk, evs.Def, evs.SpA, evs.SpD, evs.Spe];
        }
        
        function renderEVChart(evString, canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) { console.warn("Canvas no encontrado para EV chart:", canvasId); return; }
            const ctx = canvas.getContext('2d');
            const evValues = parseEVs(evString);

            if (evCharts[canvasId]) { evCharts[canvasId].destroy(); }

            evCharts[canvasId] = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['HP', 'Atk', 'Def', 'SpA', 'SpD', 'Spe'],
                    datasets: [{
                        label: 'EVs', data: evValues, backgroundColor: 'rgba(59, 76, 202, 0.2)',
                        borderColor: 'rgba(59, 76, 202, 1)', borderWidth: 2, 
                        pointBackgroundColor: 'rgba(59, 76, 202, 1)', pointRadius: 3, 
                        lineTension: 0.1 
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, 
                    scales: { r: { angleLines: { display: true }, suggestedMin: 0, suggestedMax: 252, pointLabels: { font: { size: 9 } }, ticks: { stepSize: 63, backdropColor: 'rgba(255,255,255,0.75)' } } }, 
                    plugins: { legend: { display: false }, tooltip: { enabled: true } }
                }
            });
        }

        function extractYouTubeVideoID(url) {
            const regExp = /^(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
            const match = url.match(regExp); return (match && match[1]) ? match[1] : null;
        }
        function getDefensiveEffectiveness(pokemonTypes, attackingType) {
            let finalMultiplier = 1;
            for (const defType of pokemonTypes) {
                const effectivenessChart = TYPE_EFFECTIVENESS[attackingType];
                if (effectivenessChart && effectivenessChart[defType] !== undefined) { finalMultiplier *= effectivenessChart[defType]; }
            }
            return finalMultiplier;
        }
        function analyzeAndDisplayTeamWeaknesses(teamPokemons, listElement) {
            if (!listElement || !teamPokemons) return;
            const teamWeaknesses = {};
            ALL_TYPES.forEach(attackingType => {
                let weakToThisTypeCount = 0;
                teamPokemons.forEach(pokemon => {
                    const effectiveness = getDefensiveEffectiveness(pokemon.apiTypes || pokemon.types, attackingType);
                    if (effectiveness >= 2) { weakToThisTypeCount++; }
                });
                if (weakToThisTypeCount > 0) { teamWeaknesses[attackingType] = weakToThisTypeCount; }
            });
            listElement.innerHTML = '';
            if (Object.keys(teamWeaknesses).length === 0) { listElement.innerHTML = '<li>El equipo no tiene debilidades x2 o x4 destacadas.</li>'; return; }
            for (const type in teamWeaknesses) {
                const li = document.createElement('li');
                li.innerHTML = `<div class="type-name-container"><span class="type-tag" style="background-color: ${getTypeColor(type)};">${type.toUpperCase()}</span></div> <span class="count weak">${teamWeaknesses[type]} Pokémon</span>`;
                listElement.appendChild(li);
            }
        }
        function getOffensiveEffectiveness(attackingMoveType, targetPokemonTypes) {
            let finalMultiplier = 1;
            for (const targetType of targetPokemonTypes) {
                const effectivenessChart = TYPE_EFFECTIVENESS[attackingMoveType];
                if (effectivenessChart && effectivenessChart[targetType] !== undefined) { finalMultiplier *= effectivenessChart[targetType]; }
            }
            return finalMultiplier;
        }
        function analyzeAndDisplayOffensiveCoverage(teamPokemons, listElement) {
            if (!listElement || !teamPokemons) return;
            const teamOffensiveCoverage = {};
            ALL_TYPES.forEach(targetDefendingType => {
                let strongAgainstThisTypeCount = 0;
                teamPokemons.forEach(pokemon => {
                    let pokemonIsStrong = false;
                    if (pokemon.apiMoves) {
                        for (const move of pokemon.apiMoves) {
                            if (move.damage_class !== 'status') {
                                const effectiveness = getOffensiveEffectiveness(move.type, [targetDefendingType]);
                                if (effectiveness >= 2) { pokemonIsStrong = true; break; }
                            }
                        }
                    }
                    if (pokemonIsStrong) { strongAgainstThisTypeCount++; }
                });
                if (strongAgainstThisTypeCount > 0) { teamOffensiveCoverage[targetDefendingType] = strongAgainstThisTypeCount; }
            });
            listElement.innerHTML = '';
            if (Object.keys(teamOffensiveCoverage).length === 0) { listElement.innerHTML = '<li>El equipo no tiene coberturas ofensivas súper efectivas destacadas.</li>'; return; }
            for (const type in teamOffensiveCoverage) {
                const li = document.createElement('li');
                li.innerHTML = `<div class="type-name-container">Contra <span class="type-tag" style="background-color: ${getTypeColor(type)};">${type.toUpperCase()}</span></div> <span class="count resist">${teamOffensiveCoverage[type]} Pokémon</span>`;
                listElement.appendChild(li);
            }
        }

        function renderComments(commentsArray = [], listElement, sortBy = 'newest') {
            if (!listElement) return;
            listElement.innerHTML = ''; 
            
            let sortedComments = [...commentsArray];
            if (sortBy === 'newest') {
                sortedComments.sort((a, b) => new Date(b.date) - new Date(a.date));
            } else if (sortBy === 'mostVoted') {
                sortedComments.sort((a, b) => (b.votes || 0) - (a.votes || 0));
            }

            if (sortedComments.length === 0) {
                listElement.innerHTML = '<li>No hay comentarios todavía. ¡Sé el primero!</li>';
                return;
            }
            sortedComments.forEach(comment => {
                const li = document.createElement('li');
                li.classList.add('comment-item');
                li.dataset.commentId = comment.id;
                li.innerHTML = `
                    <div class="comment-header">
                        <span class="comment-author">${comment.author}</span>
                        <span class="comment-date">${new Date(comment.date).toLocaleDateString('es-ES', { year: 'numeric', month: 'long', day: 'numeric', hour:'2-digit', minute:'2-digit' })}</span>
                    </div>
                    <p class="comment-text">${comment.text.replace(/\n/g, '<br>')}</p>
                    <div class="comment-actions">
                        <button class="vote-button" data-action="upvote" title="Me gusta">👍</button>
                        <span class="vote-count">${comment.votes || 0}</span>
                        <button class="reply-button" title="Responder (Próximamente)">↪️ Responder</button>
                    </div>`;
                listElement.appendChild(li);
            });

            listElement.querySelectorAll('.vote-button').forEach(button => {
                button.addEventListener('click', handleVoteClick);
            });
            listElement.querySelectorAll('.reply-button').forEach(button => {
                button.addEventListener('click', () => alert("La función de responder a comentarios estará disponible próximamente."));
            });
        }
        
        function handleVoteClick(event) {
            const button = event.currentTarget;
            const commentItem = button.closest('.comment-item');
            if (!commentItem) return;
            const commentId = commentItem.dataset.commentId;
            const sortDropdown = document.getElementById('sort-comments');

            if (currentTeamDataForDetail && currentTeamDataForDetail.comments) {
                const commentIndex = currentTeamDataForDetail.comments.findIndex(c => c.id === commentId);
                if (commentIndex > -1) {
                    if (!currentTeamDataForDetail.comments[commentIndex].votes) {
                        currentTeamDataForDetail.comments[commentIndex].votes = 0;
                    }
                    currentTeamDataForDetail.comments[commentIndex].votes++;
                    
                    localStorage.setItem('currentTeamDetails', JSON.stringify(currentTeamDataForDetail));
                    let allTeams = JSON.parse(localStorage.getItem('allTeamsData')) || {};
                    if(allTeams[currentTeamDataForDetail.id]) {
                        allTeams[currentTeamDataForDetail.id] = currentTeamDataForDetail;
                        localStorage.setItem('allTeamsData', JSON.stringify(allTeams));
                    }
                    renderComments(currentTeamDataForDetail.comments, document.getElementById('comments-list'), sortDropdown ? sortDropdown.value : 'newest');
                }
            }
        }

        function showFeedback(element, message, isError = false) {
            if (!element) return;
            element.textContent = message;
            element.className = 'feedback-message ' + (isError ? 'error' : 'success');
            element.style.display = 'block';
            setTimeout(() => { if(element) element.style.display = 'none'; }, 3000);
        }
    </script>
</body>
</html>
